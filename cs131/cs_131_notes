CS 131

--------------------------------------------------------------------------------
1. Lecture 1 (April 3)
--------------------------------------------------------------------------------
  * What does “safe” mean?
    - Memory errors in C/C++ code are the major source of security 
      vulnerabilities.
      a) I.e buffer overflows, dangling pointers, null dereference 
  * Most languages other than C/C++ are memory safe.
    - No possibility for the above memory errors.
    - More generally, no way to get into an undefined state.
    - How can we achieve this?
        a) Pointers are not exposed by the language.
        b) Memory cannot be explicitly freed.
        c) Memory safety checks are performed during execution.
          ∙ Array bounds checks, null pointer checks.
  * OCaml
`    - Functional Programming: encourages a style of programming where variable 
      never reassigned after initialization.
      a) No "side effects"
        ∙ A function is a pure (mathematical) function: every time you call
          it with the same argument value, it returns the same result.  
          ~ Why is this a good thing?
              * Easy parallelism
              * Greatly simplifies program reasoning.
                  - Don't have to worry about something getting overwritten.
    - Much simpler language design
  * Can download it at ocaml.org
  * What can you do with ocaml
  	- Arithmetic
      a) i.e 42 + 8 ;;
    - Variables assignment using "let"
      a) let x = 42 + 8;;
      b) immutable - can't change the value after the fact.
    - Define Functions
      a) "function" var "->" body 
      b) i.e let double = (function z -> z * 2);;
        ∙ call function like this: double 45 
      c) Can also call function like this let double z = z * 2 and it will 
         infer that you are trying to declare a function.
    - Recursion
      a) let rec factorial = 
           (function n -> if n=0 then 1 else n*(factorial (n-1))) 
    - Pattern Matching
__________________________________________________    
CODE  a) i.e let rec factorial n = 
               match n with 
                 0 -> 1
               | _ -> n * (factorial (n-1))
__________________________________________________
    - Write a function:
_________________________________________________     
CODE  a) let rec isEven n = 
         match n with
           0 -> True
         | 1 -> False
         | _ -> isEven(n-2)
__________________________________________________    
CODE  b) let rec isEven n = 
        match n with
          0 -> True
        | 1 -> False
        | _ -> isEven(if n > 0 then n-2 else n+2)
__________________________________________________          
    - Lists
      a) I.e [];; empty list
      b) i.e [1;2;3];;
      c) ["hi"; "there"]
      d) [[1;2;3]; [4;5;6]]
      e) [(function x -> 2*x); (function x -> 4*x)]
      f) Sum elements of list
____________________________________          
CODE    ∙ let rec sumLst l = 
             match l with
                 [] -> 0
             | h::t -> h + sumLst(t)
____________________________________  

--------------------------------------------------------------------------------
2. Lecture 2 (April 5)
--------------------------------------------------------------------------------
  * A grammar for the subset of Ocaml we've seen 
    - E ::= C | X | E OP E 
         | function P -> E
         | if E then E else E
         | match E with P -> E '|' ... '|' P -> E
         | [] | E :: E
         | let P = E in E

      a) C ::= 0 | 1 | 2 | ... | true | false
      b) X ::= Variable Names
      c) OP ::= + | - | * | < | ...
      d) P ::= C | _ | X | P::P
  * Lists
    - h::t is checking whether l is a list and then returns a name for the 
      first element of the list "h" and a name for the rest of the list "t"     
      a) We can also specify what to name in the list
        ∙ let l = [1;2;3]
        ∙ h::t = l
          * h = 1, t = [2;3]
        ∙ h1::h2::t = l
          * h1 = 1, h2=2, t = [3]

    - We create a function called every other that returns every other element
___________________________________________________________    
CODE  a) let rec everyOther l =
            match l with 
              [] -> []
            | first::_::rest -> first :: (everyOther rest)
            | _  -> l
___________________________________________________________            
    - Declaring Local Variables
      a) Example
        ∙ let double n = n * 2
        ∙ let quadruple n = (double n) + (double n)
         * This is inefficient we can make this function better
_______________________________
CODE     * let quadruple n = 
            let d = (double n)
            in d + d;
_______________________________
       b) We can declare more than one just nest them
  * Tuples  
    - Can be used to pass multiple arguments to a function
CODE    a) Example: let add (x,y) = x + y
CODE    b) Example: let swap = 
                     function (x,y) -> (y,x);; 

    - Create a function zip which given two list returns a list of tuples
______________________________________________________        
CODE    a) let zip (l1, l2)
      	   match (l1,l2) with 
      	     ([],[]) -> []
      	   | (h1::t1,h2::t2) -> (h1,h2) :: zip(t1,t2)
______________________________________________________
    - Try to write unzip take a list of pairs and create two lists.
  * Functions are just like any other expression
    - can be passed to other functions
    - can be stored in variables/lists
    - can be returned from functions
CODE  a) Example: let quadruple x = double(double x);;
CODE  b) Example: let fourthPower x = square(square x);;
CODE  c) Example: let twice (f,x) = f(f x)
CODE  d) Example: let quadruple x = twice(double x)
      e) We can change twice 
CODE    ∙ let twice = function f -> (function x -> f(f x)) 
        ∙ we can use it to change quadruple
          * let quadruple = twice double
    - "fun"
      a) Does what we did in e), use a function within a function.
CODE    ∙ let twice = fun f x -> f(f x)
    - Functions can also be returned
      a) twice' takes one argument f and returns a new function that takes
         the second argument x and does the computation
CODE    ∙  let twice' = function f -> (function x -> f(f x))
        ∙ Shorthand 
CODE   	  * let twice' = fun f x -> f(f x)
CODE   	  * let twice' f x = f(f x)

    - Example:
_______________________________________________    
CODE	let rec incLst l = 
    		match l with
    			[] -> []
    		   | h::t -> (h+1)::(incLst t)
________________________________________________

   	- Example:
__________________________________________________________    	
   		let rec exclaimLst l =
   		    match l with 
   		    	[] -> []
   		      | h::t -> (h ^ "!")::(exclaimLst t)
__________________________________________________________    		
    - Example
__________________________________________________________        
    	let rec map f l
    	    match l with 
    	        [] -> []
    	       | h::t -> (f h)::(map f t)
__________________________________________________________

      ∙ We can rewrite incLst and exclaimLst like this:
        * let incLst = map (function x -> x+1)
        * let exclaimLst = map (function x -> x ^ "!") 
    - What if we want to increment each element in a list of lists.
      ∙ map (map (function x -> x+1)) 
    - We want to filter a list that contains elements that satisfy a condition
      ∙ List.filter (function x -> x > 2) 
      ∙ List.filter (function x -> x mod 2 = 0)
__________________________________________________________    
    - let rec filter p l = 
    	match l with
    		[] -> []
    	   | h::t -> 
    	   		let rest = filter p t 
    	   		in if p h then h::rest else rest
__________________________________________________________    			

--------------------------------------------------------------------------------
3. Lecture 3.
--------------------------------------------------------------------------------
  * map 
    - ('a -> 'b) -> ('a list -> 'b list)
    - Note if we have ('a -> 'b) * 'a list -> 'b list
      ∙ Forces a tuple to be sent, unlike currying which wont require that. 
    - Functional programming is the correct paradigm for large programs that
      need parallelism.
CODE- let incBy l n = List.map (function x -> x + n) l;; 
      ∙ Will increase the list by a specified number. 
  * Map does not always help since it always returns a list what if we
   	 want a number.
   	- For example:
__________________________________________________________    	
      ∙ let rec prodList l = 
    		match l with 
    			[] -> 1
    	  	| h::t -> h * prodlist(t)
		
      ∙ let rec sumList l = 
    		match l with 
    			[] -> 0
    	  	| h::t -> h + sumlist(t)
__________________________________________________________

   	- We want to fold the list into a number.
__________________________________________________________________________________    	
   	  ∙ let rec (combineInts: (int -> int -> int) -> int list -> int -> int) =
   	  	    fun f l b -> 
   	  		match l with
   	  			[] -> b
   	  		  | h::t -> f h (combineInts f t b)
___________________________________________________________________________________

   	  ∙ Usage:
   	    a) combineInts (fun x y -> x + y) [1;2;3;4] 0;;
   	    b) sumList l = combine(func x y -> x+y) l 0;;

   	  ∙ Formally combineInts f (x1;...;xn) b = f x1 (f x2 (... (f xn b) ... ))
  * Aside: We can also write the result above as such
    - combineInts (+) [1;2;3;4] 1;;
    - Note for product use "( * )" not "(*)" since "(*" is the start of the
      comment. 
   	- Note be careful about non commutative operators.
  * Use combineInts to calculate the length of the list
    - let lengths l = combineInts (function x y ->  y + 1) l 0;
      ∙ x is the element of the list and y is the result of the base case.
  * CombineInts is more general
_______________________________________________________________________________ 
    - let rec fold_right =
   	  	    fun f l b -> 
   	  		match l with
   	  			[] -> b
   	  		  | h::t -> f h (fold_right f t b)
_____________________________________________________________________________  

   	- type: ('a -> 'b -> 'b) -> 'a list -> 'b -> 'b
   	  ∙ 'a stands for the type of the elements of the list
   	  ∙ 'b stands for the type of the result of our list.
    - let allpos l = fold_right 
     			(fun elem restIsPos ->  (elem>0) && restIsPos) l true;;
    - We can generalize allpos to a function which checks if all elements of 
       a list satisfy a condition.
      ∙ let all p l = fold_right (fun elem rest -> (p elem) && rest) l true;
    - Lets write "@" (append) with fold_right
      ∙ First lets write it recursively
        a) let rec append l1 l2 = 
         		match l1 with 
         			[] -> l2
         		| h::t -> h::(append t l2)
      ∙ let append l1 l2 =
      	    	   fold_right (fun elem appendedRest -> elem::appendedRest)
									l1 l2;
    - Create a function to duplicate the list
	  ∙ let dupList l = fold_right
	    		(fun elem dupRest -> elem::elem::dupRest) l []
  * fold_right/left2
  	- let dotProd l1 l2 = 
  		list.fold.right2 (fun e1 e2 restDotProd -> e1*e2 + restDotProd)
									l1 l2 0;
  * What have we learned so far?
  	- Key control structures: Recursion and pattern matching
  	- Key data structures: Lists and tuples
  	- First-class function: a little of both. 
    - MISSING:
      ∙ user defined types.
      ∙ privacy/protection/encapsulations

  * Ocaml lets you define your own data-types 
  	- Similar to structs in C or classes in Java
  	- differences data-types are designed for 
  	  ∙ immutability
  	  ∙ 

  * Data-type that represents signs
    - type sign = Pos | Neg | Zero;;
    - ocaml requires that data-types be lowercase and their values start with
      a upper case.
    - Does not do anything yet, we need to write functions that use "sign"
      ∙ let signOF n = 
      		match n with 
      			0 -> zero
      		  | _ -> if n>0 then Pos else Neg;;		
    - Now we get a sign and return an int
      ∙ let signToInt s = 
      		match s with
      			pos -> 1 
      		  | neg -> -1
      		  | zero -> 0;;
    - Create a type that represents two dimensional points
      ∙ type point = Pt of float * float
      ∙ Pt is now a constructor, Pt itself is not a point.
    - Write a funct to negate a point
      ∙ let negate p = 
      		match p with
      			pt (x,y) -> Pt (-. x, -. y);;

--------------------------------------------------------------------------------
4. Lecture 4
--------------------------------------------------------------------------------
  * Recall
    - type sign = Pos | Neg | Zero
    - We cannot do much with "sign", we could create functions that
      mess with "sign".
      ∙ Let intToSign n =
      	    match n with
	     0 -> Zero
	    | _ when n > 0 -> Pos
	    | _ -> Neg
      ∙ Let signToInt s -
      	    match s with
	     pos -> 1
	    | neg -> -1
	    | zero -> 0

  * More complex data-types
    - type shape = Circle of float | Rect of float * float
      ∙ Usage: Circle <x = float> => shape = Circle x
        Usage: Rect <(x=float, y = float)> => shape = Rect (x,y)
    - We create a function that operates on "shape" types
      ∙ let area s =
      	  match s with
	    Circle r -> 3.14 *. r *. r
	    | Rect (l,w) -> l *. w
  * There is no notion of null in ocaml
    - Languages have null as a placeholder for values.
    - We can implement null in ocaml
      ∙ type nullableInt = Null | Nonnull of Int
    - Here nullableInt is not the same is Int, it forces you to check if its
      null. Other languages don't require this.
    - We create a function to get the int in nullableInt
      ∙ let nullableIntToInt n =
      	 match n with
	   Null -> 0
	 | Nonnull i -> i
    - Create a function that will add 1 to a nullableInt unless it is Null.
      ∙ let incNullableInt n =
      	 match n with
	  Null -> Null
	| Nonnull i -> Nonnull (i+1)
    - We create a function that will perform operations on NullableInt in a
      safe way.
      ∙ let updateNullableInt f n =
      	  match n with
	    Null -> Null
	  | Nonnull i -> Nonnull (f i)
    - We can make nullableInt to work with any type of data be polymorphic.
      ∙ type 'a nullable = Null | Nonnull of 'a
    - Same implementation in standard library called option and it has types
      "None" and "Some".
    - Function that gives you the nth element of a list. We want to return
      something if n is larger than length of the list.
      ∙ My implementation
      	let  rec nth n l =
      	  match n with
	    0 ->
	        match l with
	          [] -> None
	        | h::t -> Some h 
	    _ ->
	        match l with
	          [] -> None
	        | h::t ->  Some nth (n-1) t
      ∙ Class implementation
        let rec nth n l =
	 match n with
	   0 -> 
	        match l with
	          [] -> None
	        | h::t -> Some h
	 | _ when n < 0 -> None
	 | _ ->
	        match l with
	          [] -> None
		| h::t -> nth (n-1) t
      ∙ We can condense it
        let rec nth n l =
	  match l with
	    [] -> None
	  | h::t ->
	    match n with
	    0 -> Some h
	  | _ when n < 0 -> None
	  | _ -> nth (n-1) t
	
      ∙ We can condense even further
        let rec nth n l =
	    match (n, l) with
	      (_, []) -> None
	    | (_,_) when n < 0 -> None
	    | (0,h::t) -> Some h
	    | (_, h::r) -> nth (n-1) t
  * Need to be able to define data-types in terms of themselves.
    - For example making lists
      ∙ type intlist = Empty | Node of int * intlist
      ∙ [1;2;3] is represented as Node(1, Node(2, Node(3, Empty)))
    - Can convert both ways
      ∙ let rec toIntList l -
      	  match l with
	    [] -> Empty
	  | h::t -> Node(h, toIntList t)
      ∙ let rec fromIntList l =
      	  match l with
	    Empty -> []
	  | Node(h,t) -> h:: (fromIntList t)
    - Can make lists polymorphic
      ∙ type 'a mylist = Empty | Node of 'a * 'a mylist
    - Can create our own version of Map as well
      ∙ let rec mymap f l =
      	  match l with
	  Empty -> Empty
       |  Node(h,t) -> Node((f h), (mymap f t))
  * Binary Trees (data on internal nodes not leaves)
    - type 'a mytree = Leaf | InternalNode of 'a * 'a mytree * 'a mytree
    - Function that will calculate the size (length of a tree)
      ∙ let rec size t =
      	  match t with
	     Leaf -> 0
	   | InternalNode(_,r,l) -> 1 + (size l) + (size r)
    - let rec preorder t =
          match t with
	    Leaf -> []
	  | InternalNode(d,r,l) -> [d] @ preorder(l) @ preorder(r)
      ∙ Move [d] to the middle and you get
      ∙ Mode [d] to the right you get
    - Insertion into a binary tree
      ∙ let rec insert x t =
      	    match t with
	      Leaf -> Node(x, Leaf, Leaf)
	    | InternalNode(d, l ,r) ->
	      		      if (x < d) then InternalNode(d, (insert x l), r)
			      else InternalNode(d, l, (insert x r))

--------------------------------------------------------------------------------
5. Lecture 5
--------------------------------------------------------------------------------
  * Scoping
    - Key Question: Which variable declaration does a particular variable
      usage refer to.
    - The language maintains during execution an ENVIRONMENT
      ∙ Mapping from variable names to their values
      ∙ A data structure which is constantly being updated.
      ∙ At the start of a program the environment is empty and as we declare
      	variables the environment binds the variables to their values.
        a) You cant think of the environment as a list of tuples for example:
	   [("x",3);("y", 100);...]
    - Consider let double = (function n -> n*2)
      ∙ This creates an environment where "double" can be instantiated and
      	updated it is destroyed when the function returns.
      ∙ For this example our environment now has the following
      	[("double"), <fun>)]
      ∙ When we make a call like (double 34) ("n", 34) gets temporarily put in
      	the environment, it get returned to the original environment at the
	end of the function.
      ∙ Note double is not in the environment when we make a call like the one
      	above, this would give us an error. This can only be done when we have
	a recursive function.
      ∙ What is actually going to happen is that every environment is going to
      	have its own environment.
      ∙ Here is another example suppose we do the following after declaring
      	double.
        a) let x = 3;;
	b) let three() = x
	   1) Will output int=3 since our environment is
	      [("double", <fun>),("x",3)]
    - Local Variable Declarations
      ∙ DEFINITION Static/Lexical Scoping: A variable reference refers to the
      	declaration of the that variable that is nearest  in the enclosing
	scope TEXTUALLY.
        a) Can statically (at compile time) determine the variable declaration
	   associated with each variable usage.
      ∙ Consider the following example
        a) $ Environment []
	  let y = 3 in
	   $ Environment [("y",3)]
	     let z = y * 2 in
	   $ Environment [("y",3); ("z",6)]
	       	 y + z
	   $ Environment []
      ∙ DEFINITION Dynamic Scoping: A variable reference
      ∙ How is Dynamic Scoping difference than Static Scoping
        a) Environment for static scoping:
	   $ Environment []
	   # let x = 45
	   $ Environment [("x",45)]
	   # let add45 = (function y -> y + x)
	   $ Environment [("x", 45); ("add45", <fun>)]
	   # add45 3 ===> int = 48
	   # let x = 12
	   $ Environment [("x", 12); ("add45", <fun>)] // This implies that
	     		 	     	       	       	  add45 contains a
							  record of ("x",45) as
							  such:
				     [("x",12); ("add45", (<fun>, [("x", 45)]))]
	   # add45 3 ===> int = 48
	   # x ===> int = 12
	   # x = "hello"
	   # add45 3 ===> int = 48
	 b) To make static scoping work, every function has to keep its
	    static environment with it. That environment is used when the
	    function is called.
    - Variable Shadowing
      ∙ let x = 34 in
      	    let y = x + 1 in      // using x = 34
	    	let x = x + 32 in // using x = 34
		  x + y;;         // using x = 66, earlier x is being shadowed
    - Another Example
      ∙	$ Environment []      
        # let add = (function x -> function y -> x + y)
	$ Environment [("add", (<fun>, []))]
	# let add45 = add 45
	$ Environment [("add", (<fun>, [])),
	  	       ("add45", (fun y -> x + y, [("x", 45)]))]
	# add45 3 ===> int = 48
	# let x = 12
	$ Environment [("add", (<fun>, [])),
	  	       ("add45", (fun y -> x + y, [("x", 45)])),
		       ("x", 12)]
	# add45 3 ===> int = 48
    
--------------------------------------------------------------------------------
6. Lecture 6
--------------------------------------------------------------------------------
* Types

  - Goal is to ensure that operations are only invoked with arguments of the
    right types
    
    ∙ Basic sanity check.
    ∙ Cal also be used to enforce requirements on user-defined types.
    
  - Static Vs Dynamic typechecking
  
    ∙ DEFINITION STATIC: means that you try to ensure the above goal at compile
      time.
      
      a) Give a type to each program expression without running code.
      b) Signal a compile-time error if not possible.
      
    ∙ DEFINITION DYNAMIC: means that you check that an operation has arguments
      of the right type just before you execute the operation.

      a) If ok; Execute the operation.
      b) if not ok; throw an exception.
      
    ∙ Static is better than dynamic for large programs.

  - Strongly typed Vs Weakly typed.
  
    ∙ a second dimension to evalue at type system.
    ∙ DEFINITION WEAKLY TYPED: means there are certain type errors that the
      language does not protect against.
      
      a) it's possible to treat a value one type accudentally as if it has
      	 another type.
      b) Implementation-dependent behavior.
      c) C/C++
      d) Key Issue: Memory Safety
      
        1) Memory errors in C
	
	  ‣ Out-of-bounds accesses ("Buffer Overrun"). The leading cause of
	    security exploits.
	  ‣ "Dangling Pointers". Free a pointer too early.
	  ‣ Uninitialized Pointers.

    ∙ DEFINITION STRONGLY TYPED: means that the type system achieves the above
      goal 100% of the time.
      
      a) Ocaml, Python, Javascript      
      b) How do strongly typed languages avoid the errors of weakly typed
      	 languages?
	 
        1) Pointers are hidden
	2) Run-time bounds checks on every array acces
	3) Garbage collection at run time to free memory that's no longer used.
	4) Pointers must be initialized before use.

  - Does Ocaml have pointers?
  
    ∙ Yes everything is a pointer for example:
    
      a) let l = [1;2;3];
      
        1) l[*] --> [1 | --]--> [2 | --]-->[3 |--]-->@
	
      b) let l2 = 0::l;;

        1) l[*] -------> [1 | --]--> [2 | --]-->[3 |--]-->@
                          ^
			  ^
			  |
	2) l2[*] --> [0 | --]

  - Summarize:
  
    ∙ Static/Strong: Ocaml, Java, C#
    ∙ Static/Weak: C, C++
    ∙ Dynamic/strong: Javascript, Python, Lisp
    ∙ Dynamic/Weak: ???

  - Can make types fancier to catch more errors at compile time.
  
    ∙ Example: transpose has type matrix -> matrix

      a) Better: matrix<m,n> -> matrix<n,m>

* Exceptions

  - Why do they exists and what are they good for?
  - An association list if a list of pairs i.e
  
    ∙ [(1, "h1"), [2, "There"]]
    
  - We want to write a lookup function
  
    ∙ How do we deal with a key that is not in the list?
    
      a) First idea: Options
      
        1) lookup: 'a -> ('a and 'b) list -> 'b option
	   let rec lookup k l =
	       match l with
	          [] -> None
	      | (key,v)::t -> if (key = k) then Some v else (lookup k t)
	2) Advantages and Disadvantafes of this approach
	
	  ‣ Advantage: It makes the error case very explicit
	  ‣ Disadvantage: It forces every caller to deal with the error.
	  
	    † Let lookupAndExclaim k l =
	          let vopt = lookup k l in
		  match vopt with
		     None -> None
		 | Some s -> Some (s^"!")		 
            † We have to pattern match again to make sure we have correct
	      behavior.
            † Lookup a bunch of keys and return None if any of them is missing.
	    
	      ◊ Let rec lookupAll ks l =
	      	    match ks with
		        [] -> None
		     | k::rest ->
		       let vopt = lookup k l in
		       match vopt with
		           None -> None
			 | Some v ->
			   let vsopt = lookupAll rest l in
			   match vsopt with
			       None -> None
			     | Some vs -> Some (v::vs)
			     
  - What we want from exceptions:
  
    ∙ Clear indication of an error
    ∙ Clean separaion of error handling code from ordinary functionality
    ∙ Allow callers to easily pass throught the error if they can't handle it.

  - We will create a lookup function using exceptions
  
    ∙ Example:
      exception NotFound
      let rec lookup k l =
          match l with
	     [] -> raise NotFound
	  | (Key, v)::t -> if key = k then val else lookup k t

    ∙ Example: Implicitely propagates the exception
      exception NotFound
      let lookupAndExclaimE k l =
          (lookupE k l) ^ "!"

  - What if we want to catch the error?
  
    ∙ Example: I want to return "error" if there's an error.
      let lookupAndExclaimTry k l =
         try
	    (lookupE k l) ^ "!"
	 with
	    NotFound -> "error"
	    
  - Here we fix the funciton lookupAllE
  
    ∙ let lookupAllE ks l =
          List.map (fun k -> lookupE k l) ks

  - We can catch the error 
    ∙ let lookupAllTry ks l
      	  try
	      Some (List.map (fun k -> lookupE k l) ks)
	  with
	      NotFound -> None
  - We can specify the keys that are found or not found.
    ∙ let lookupAllTry2 ks l =
          List.map (fun k -> try Some (lookupE k l) with NotFound s -> None) ks

--------------------------------------------------------------------------------
7. Lecture 7
--------------------------------------------------------------------------------

* Parametric Polymorphism (Generics)
  
  - a way to make statically typed languages more expressive.
  - ocaml wont run
  
    ∙ [1;2;3.3]
    ∙ if true 1 else 1.1
    
  - Helps us write a function that does not have to know the types of
    certain parameters for example
    
    ∙ Without PP: This will throw an error if we pass an int list
    
      1) let rec length (l: bool list) : int =
      	      match l with
	         [] -> []
	        | _::t -> 1 + (length t)
		
    ∙ With PP: This will work with a list of anything
    
      2) let rec length l : int =
      	     match l with
	     	[] -> []
	      | _::t -> 1 + (length t)

        a) val lenght : 'a list -> int = <fun>
	
	  ‣ 'a is a "type" varible.
	  ‣ 'a is implicitly instantiated on each call to length.

  - Typechecking without PP
  
    ∙ let pos x = x >0   (*val pos : int -> bool = <fun>*)
    ∙ How to typecheck this call
    
      1) pos 45;;
      
        a) lookup the type double: int -> bool
	b) compute the type 45: int
	c) check that the actual and formal parameters types are equal.
        d) the type of the whole thing is the result type of the function: bool.

  - Typechecking with PP
  
    ∙ length [true; false; true]

      1) length [true, false, true];;
    
        a) look up the type length: 'a list -> int
	b) Compute the type [True; false; true]: bool list
	c) Check that we an find an instantiation of 'a with some type
	   that makes the atual and formal parameter types be equal:
	   'a bool
	d) The type of the whole thing is the result type of the function : int.

    ∙ rotate (1, "hi", 3.14)
    
      1) lookup the type rotate: ('a -> 'b -> 'c) -> ('c * 'a  *'b)
      2) Compute the type (1, "hit", 3.14): int * string * float.
      3) Check that we can find an instatniation of 'a, 'b, and 'c  with types
      	 that meakes the actual and formal paramater types be equal:
	 
	   a) 'a = int
	   b) 'b = string
	   c) 'c = float

      4) The type fot he whole thing is the instantiated version of the result
      	 type of the function: float*int* string

  - KEY IDEA: Parametric polymorphism
  
    ∙ One function
    ∙ Can pass many different types of arguments.

  - Contrast with static overloading
  
    ∙ Many functions
    ∙ They all have the same name.

  - Two operators in ocaml are "overloaded"
  
    ∙ (< , >) greater/less than
    
      1) 1 > 2
      2) 1.1 > 2.2
      3) "hello" > "hi"
      
    ∙ = equality operator
    
      1) 1 = 2
      2) 1.1 > 2.2
      3) "hello" = "hi"

* Mini-Ocaml Interpreter

  - Given: Some string of characters input at the command line
  - STEP 1: Parse the given string of characters.

    ∙ Convert it into a sequence of "tokens"
    ∙ Parse the sequence of tokes
    ∙ If grammatically incorrect, then reject (parse error)
    ∙ otherwise produce a data structure called an abstract syntax tree (AST)

      1) Unambiguously represent the code.
      
    ∙ Has already been implemented for us.

  - STEP 2 [in a statically typed language]:
  
    ∙ Typecheck the program.
    ∙ If error then reject (type error), otherwise move to the next step.
    ∙ MOCaml does not have static typechecking.
    ∙ Instead we'll do dynamic typechecking.

  - STEP 3: Execute program.
  
    ∙ Recursive traversal of the AST.
    
      1) Compositional:
      
      	 a) Compute the values of subexpressions
	 b) Figure out to combine them to produce the overall value.
	 
      2) Need to handle environment properly to account for variable scoping
      
    ∙ let rec evalExpr
    
      1) If(guard, thn, els) ->
      	 	   (match evalExpr guard env with
		          BoolVal true -> evalExpr thn env
			| BoolVal false -> evalExpr els env
		 	| _ ->  raise (DynamicTypeError "boolean guard expected") )

  - STEP 4: Print an OCaml representation of the result.
  - STEP 5: goto STEP 1.
    
  